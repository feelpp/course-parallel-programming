<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SPECX Coding Practice :: Parallel Programming</title>
    <link rel="canonical" href="https://feelpp.github.io/parallel-programming/parallel-programming/SPECX_Coding.html">
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../_/css/site.css">
<link rel="icon" href="../_/img/favicon.ico" type="image/x-icon">
<script>!function(l,p){if(l.protocol!==p&&l.host=="docs.antora.org"){l.protocol=p}else if(/\.gitlab\.io$/.test(l.host)){l.replace(p+"//docs.antora.org"+l.pathname.substr(l.pathname.indexOf("/",1))+l.search+l.hash)}}(location,"https:")</script>

<script src="../_/js/vendor/tabs-block-extension.js"></script>
<script src="../_/js/vendor/tabs-block-behavior.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    processEscapes: true,
    processEnvironments: true,
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },

  TeX: {
      Macros: {
      bold: ["{\\bf #1}",1],
      calTh: "{\\mathcal{T}_h}",
      card: ["{\\operatorname{card}(#1)}",1],
      card: ["{\\operatorname{card}(#1)}",1],
      Ck: ["{\\mathcal{C}^{#1}}",1],
      deformt: ["{\\mathbf{\\varepsilon(#1)}}",1],
      diam: "{\\operatorname{diam}}",
      dim: ["{\\operatorname{dim}(#1)}",1],
      disp: ["{\\mathbf{#1}}",1],
      domain: "{\\Omega}",
      ds: "",
      essinf: "{\\operatorname{ess}\\, \\operatorname{inf}}",
      F:"{\\mathcal{F}}",
      geo: "{\\mathrm{geo}}",
      Ich: ["{\\mathcal{I}^{#1}_{c,h}#2}",2],
      Id: "{\\mathcal{I}}",
      Ilag: ["{\\mathcal{I}^{\\mathrm{lag}}_{#1}}",1],
      jump: ["{[\\![ #1 ]\\!]}",1],
      n:"{\\mathbf{n}}",
      Ne: "{N_{\\mathrm{e}}}",
      Next: "{\\mathrm{n}}",
      nf: "{n_f}",
      ngeo: "{n_{\\mathrm{geo}}}",
      Nma: "{N_{\\mathrm{ma}}}",
      NN: "{\\mathbb N}",
      Nno: "{N_{\\mathrm{no}}}",
      Nso: "{N_{\\mathrm{so}}}",
      opdim: "{\\operatorname{dim}}",
      p: "{\\mathrm{p}}",
      P:"{\\mathcal{P}}",
      Pch: ["{P^{#1}_{c,h}}",1],
      Pcho: ["{P^{#1}_{c,h,0}}",1],
      Pk: ["{\\mathcal{P}^{#1}}",1],
      poly: ["{\\mathbb{#1}",1],
      poly: ["{\\mathbb{#1}}",1],
      prect: ["{\\left\\(#1\\right\\)}",1],
      q:"{\\mathbf{q}}",
      Qch: ["{Q^{#1}_{c,h}}",1],
      Qk: ["{\\mathcal{Q}^{#1}}",1],
      R: ["{\\mathbb{R}^{#1}}",1],
      RR: "{\\mathbb R}",
      set: ["{\\left\\{#1\\right\\}}",1],
      stresst: ["{\\mathbf{\\sigma(#1)}}",1],
      T:"{\\mathcal{T}}",
      tr: "{\\operatorname{tr}}",
      v:"{\\mathbf{v}}",
      vertiii: ["\\left\\vert\\kern-0.25ex\\left\\vert\\kern-0.25ex\\left\\vert #1 \\right\\vert\\kern-0.25ex\\right\\vert\\kern-0.25ex\\right\\vert",1]
  },
  extensions: ["mhchem.js"] 
  }
});
</script>
<!--<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>-->
<!-- <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script> -->
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML'></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>-->

<!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" integrity="sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js" integrity="sha384-jmxIlussZWB7qCuB+PgKG1uLjjxbVVIayPJwi6cG6Zb4YKq0JIw+OMnkkEC7kYCq" crossorigin="anonymous"></script>-->
<script>var uiRootPath = '../_'</script>

  </head>
  <body class="article">
<header class="header">
    <nav class="navbar navbar-expand-sm bg-dark navbar-dark navbar-template-project" style="border-top: 4px solid #9E9E9E">
        <div class="navbar-brand">
            <div class="navbar-item feelpp-logo">
                <a href="https://feelpp.github.io/parallel-programming">Parallel Programming</a>
            </div>
            <button class="navbar-burger" data-target="topbar-nav">
                <span></span>
                <span></span>
                <span></span>
            </button>
        </div>

        <div id="topbar-nav" class="navbar-menu">
            <div class="navbar-end">
                <div class="navbar-item">
                    <a href="https://docs.feelpp.org/">Documentation Reference</a>
                </div>
                <div class="navbar-item has-dropdown is-hoverable download-item">
                    <div class="navbar-item"><a href="https://docs.feelpp.org/user/latest/install/index.html" class="download-btn">Get Feel++</a></div>
                </div>
                <div class="navbar-item">
                    <a class="navbar-brand"  href="https://www.cemosis.fr">
                        <img class="cemosis-logo"  src="../_/img/cemosis-logo.svg" alt="Cemosis logo"/>
                    </a>
                </div>
            </div>
        </div>
    </nav>
</header>
<div class="body">
<a href="#" class="menu-expand-toggle"></a>
<div class="nav-container" data-component="parallel-programming" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Main</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Architectures</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architectures/PPChapter1_CPU.html">CPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architectures/PPChapter1_GPU.html">GPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architectures/PPChapter1_GPGPU.html">GPGPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architectures/PPChapter1_TPU.html">TPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architectures/PPChapter1_NPU.html">NPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architectures/PPChapter1_LPU.html">LPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architectures/PPChapter1_DPU.html">DPU Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architectures/PPChapter1_SIMD.html">SIMD Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="architectures/PPChapter1_AMD_CUDA.html">AMD CUDA Architecture</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">MPI/OpenMP/Hybrid</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="PPChapter2_MPI.html">MPI (Message Passing Interface)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="PPChapter2_MPI_Boost.html">MPI Boost</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="PPChapter2_OpenMP.html">OpenMP (Open Multi-Processing)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="PPChapter2_OpenMP2.html">OpenMP more information</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="PPChapter2_Hybrid.html">Hybrid MPI with OpenMP</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Runtime Systems</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="PPChapter3.html">StarPU</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="PPChapter4.html">Specx</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="kokkos/index.html">Kokkos</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introduction</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/introduction/why-kokkos.html">Why Kokkos?</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/introduction/installation.html">Installation &amp; Setup</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="kokkos/basic-concepts/index.html">Basic Concepts</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/basic-concepts/views.html">Views</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/basic-concepts/execution-spaces.html">Execution Spaces</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/basic-concepts/memory-spaces.html">Memory Spaces</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/basic-concepts/mirrors.html">Mirrors</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/basic-concepts/memory-access-patterns.html">Memory Access Patterns</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="kokkos/advanced-concepts/index.html">Advanced Concepts</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/advanced-concepts/advanced-reductions.html">Advanced Reductions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/advanced-concepts/multidimensional-loops-and-data-structure.html">Multidimensional Loops and Data Structure</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/advanced-concepts/hierarchical-parallelism.html">Hierarchical Parallelism</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="kokkos/advanced-concepts/mpi-pgas.html">MPI and PGAS</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Main</span>
    <span class="version"></span>
  </div>
  <ul class="components">
      <li class="component">
        <a class="title" href="../feelpp-antora-ui/index.html">Antora Feel++ UI</a>
      </li>
      <li class="component is-current">
        <a class="title" href="index.html">Main</a>
      </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
  <button class="nav-toggle"></button>
    <a href="index.html" class="home-link"></a>
  <nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Main</a></li>
    <li><a href="SPECX_Coding.html">SPECX Coding Practice</a></li>
  </ul>
</nav>

  
    <div class="edit-this-page"><a href="https://github.com/feelpp/course-parallel-programming/edit/feature/kokkos/docs/modules/ROOT/pages/SPECX_Coding.adoc">Edit this Page</a></div>
  
  <div class="page-downloads">
  <span class="label">Download as</span>
  <ul class="download-options">
    <li>
      <a onclick="print(this)" href="#" data-toggle="tooltip" data-placement="left" title="Print to PDF"
         class="pdf-download">
        <img class="pdf-file-icon icon" src="../_/img/pdf.svg"/> .pdf
      </a>
    </li>
  </ul>
</div>
</div>

  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="3">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">SPECX Coding Practice</h1>
<div class="sidebarblock examp">
<div class="content">
<div class="title">Examples</div>
<div class="listingblock">
<div class="title">Code Test Promise</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"



#include "Data/SpDataAccessMode.hpp"
#include "Utils/SpUtils.hpp"
#include "Random/SpPhiloxGenerator.hpp"


#include "mcglobal.hpp"



#include "Data/SpDataAccessMode.hpp"
#include "Utils/SpUtils.hpp"

#include "Task/SpTask.hpp"
#include "Legacy/SpRuntime.hpp"
#include "Utils/SpTimer.hpp"
#include "Utils/small_vector.hpp"
#include "Utils/SpBufferDataView.hpp"
#include "Utils/SpArrayView.hpp"
#include "Utils/SpHeapBuffer.hpp"


#include "UTester.hpp"
#include "utestUtils.hpp"



#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;



using namespace std;

template &lt;typename C&gt; void print(const string&amp; s, const C&amp; c) {
    cout &lt;&lt; s;
    for (const auto&amp; e : c) { cout &lt;&lt; e &lt;&lt; " "; }
    cout &lt;&lt; endl;
}

void fillVector(vector&lt;int&gt;&amp; v)
{
    // A local static variable.
    static int nextValue = 1;

    // The lambda expression that appears in the following call to
    // the generate function modifies and uses the local static
    // variable nextValue.
    generate(v.begin(), v.end(), [] { return nextValue++; });
    //WARNING: this isn't thread-safe and is shown for illustration only
}


int gen()
{
    static int i = 0;
    return ++i;
}

class MyFunction001
{
public:
    // The required constructor for this example.
    explicit MyFunction001(int&amp; evenCount)
        : m_evenCount(evenCount) { }

    // The function-call operator prints whether the number is
    // even or odd. If the number is even, this method updates
    // the counter.
    void operator()(int n) const {
        cout &lt;&lt; n;

        if (n % 2 == 0) {
            cout &lt;&lt; " is even " &lt;&lt; endl;
            ++m_evenCount;
        } else {
            cout &lt;&lt; " is odd " &lt;&lt; endl;
        }
    }

private:
    // Default assignment operator to silence warning C4512.
    MyFunction001&amp; operator=(const MyFunction001&amp;);

    int&amp; m_evenCount; // the number of even variables in the vector.
};




int main(int argc, char **argv)
{

    int NumThreads = SpUtils::DefaultNumThreads();

    const int NbLoops = 3;
    const int NbInnerLoops = 2;
    static_assert(NbInnerLoops &lt;= NbLoops, "Nb inner loops cannot be greater than Nb Loops");

    const int NbDomains = 5;
    const int NbParticlesPerDomain = 10;
    const double BoxWidth = 1;
    const double displacement = 0.00001;

    const int NbReplicas = 5;
    std::array&lt;double,NbReplicas&gt; betas;
    std::array&lt;double,NbReplicas&gt; temperatures;

    const double MinTemperature = 0.5;
    const double MaxTemperature = 1.5;

    for(int idxReplica = 0 ; idxReplica &lt; NbReplicas ; ++idxReplica){
        betas[idxReplica] = 1;
        temperatures[idxReplica] = MinTemperature + double(idxReplica)*(MaxTemperature-MinTemperature)/double(NbReplicas-1);
    }

    std::array&lt;size_t,NbReplicas&gt; cptGeneratedSeq = {0};

    ///////////////////////////////////////////////////////////////////////////
    /// With a possible failure move
    ///////////////////////////////////////////////////////////////////////////

    const bool runSeqMove = false;
    const bool runTaskMove = false;
    const bool runSpecMove = false;

    std::array&lt;double,NbReplicas&gt; energySeq = {0};

    const int MaxIterationToMove = 5;
    const double collisionLimit = 0.00001;


    if (1==1)
    {

        cout&lt;&lt;"===================================\n";

        NumThreads=2;
        SpRuntime My_Runtime3(NumThreads); 

        //SpRuntime&lt;SpSpeculativeModel::SP_MODEL_2&gt; My_Runtime3;
        //cout&lt;&lt;":"&lt;&lt;My_Runtime3.getValue()&lt;&lt;"\n";

        My_Runtime3.setSpeculationTest(
            [](const int /*inNbReadyTasks*/,
            const SpProbability&amp; /*inProbability*/) -&gt; bool
            {
                // Always speculate
                //usleep(50000);
                return true;
            } 
        );

        int val = 0;
        std::promise&lt;int&gt; promise3;
        //la promesse que doit remplir le thread annexe

         My_Runtime3.task(SpRead(val)
            , 
            [&amp;promise3](const int&amp; /*valParam*/)
            {
                usleep(100);
                promise3.get_future().get();
                //Retourne un objet future qui a le même état asynchrone associé que cet objet promise.
            }
        ).setTaskName("First task");

       
        
        for(int idx = 0; idx &lt; 1; idx++) {
          My_Runtime3.task(SpWrite(val), 
              [](int&amp; valParam)  
              {
                cout&lt;&lt;"CTRL Val in certain task="&lt;&lt;valParam&lt;&lt;"\n";
                usleep(500);
              }
          ).setTaskName("Certain task -- " + std::to_string(idx));
        }

        
        
        const int nbUncertainTasks = 6;

        for(int idx = 0 ; idx &lt; nbUncertainTasks ; ++idx){
            My_Runtime3.task(SpPotentialWrite(val), 
               [](int&amp; valParam) -&gt; bool
                {
                   cout&lt;&lt;"CTRL Val in uncertain task="&lt;&lt;valParam&lt;&lt;"\n";
                   usleep(1000);
                   return true;
                }
            ).setTaskName("Uncertain task -- " + std::to_string(idx));
        }
        

        /*
        for(int idx = 2; idx &lt; 4; idx++) {
          My_Runtime3.task(SpWrite(val), 
              [](int&amp; valParam)  
              {
                usleep(1500);
              }
           ).setTaskName("Certain task -- " + std::to_string(idx));
        }
        */
        
        My_Runtime3.task(SpWrite(val), 
              []([[maybe_unused]] int&amp; valParam)
              {
                usleep(2000);
              }
        ).setTaskName("Last-task");

        promise3.set_value(0);
        //L'opération se comporte comme si set_value , set_exception , 
        //set_value_at_thread_exit et set_exception_at_thread_exit acquéraient 
        //un seul mutex associé à l'objet de promesse lors de la mise à jour de 
        //l'objet de promesse.
    
        //Une exception est levée s'il n'y a pas d'état partagé ou si 
        //l'état partagé stocke déjà une valeur ou une exception.
        //Les appels à cette fonction n'introduisent pas de courses de 
        //données avec les appels à get_future (ils n'ont donc pas besoin 
        //de se synchroniser les uns avec les autres).



        My_Runtime3.waitAllTasks();

        My_Runtime3.generateDot("RuntimePromise.dot",true);
        My_Runtime3.generateTrace("RuntimePromose.svg");


    }


}



 
#pragma GCC diagnostic pop</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Test Race</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"



#include "Data/SpDataAccessMode.hpp"
#include "Utils/SpUtils.hpp"
#include "Random/SpPhiloxGenerator.hpp"


#include "mcglobal.hpp"



#include "Data/SpDataAccessMode.hpp"
#include "Utils/SpUtils.hpp"

#include "Task/SpTask.hpp"
#include "Legacy/SpRuntime.hpp"
#include "Utils/SpTimer.hpp"
#include "Utils/small_vector.hpp"
#include "Utils/SpBufferDataView.hpp"
#include "Utils/SpArrayView.hpp"
#include "Utils/SpHeapBuffer.hpp"


#include "UTester.hpp"
#include "utestUtils.hpp"



#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;



using namespace std;

template &lt;typename C&gt; void print(const string&amp; s, const C&amp; c) {
    cout &lt;&lt; s;
    for (const auto&amp; e : c) { cout &lt;&lt; e &lt;&lt; " "; }
    cout &lt;&lt; endl;
}

void fillVector(vector&lt;int&gt;&amp; v)
{
    // A local static variable.
    static int nextValue = 1;

    // The lambda expression that appears in the following call to
    // the generate function modifies and uses the local static
    // variable nextValue.
    generate(v.begin(), v.end(), [] { return nextValue++; });
    //WARNING: this isn't thread-safe and is shown for illustration only
}


int gen()
{
    static int i = 0;
    return ++i;
}

class MyFunction001
{
public:
    // The required constructor for this example.
    explicit MyFunction001(int&amp; evenCount)
        : m_evenCount(evenCount) { }

    // The function-call operator prints whether the number is
    // even or odd. If the number is even, this method updates
    // the counter.
    void operator()(int n) const {
        cout &lt;&lt; n;

        if (n % 2 == 0) {
            cout &lt;&lt; " is even " &lt;&lt; endl;
            ++m_evenCount;
        } else {
            cout &lt;&lt; " is odd " &lt;&lt; endl;
        }
    }

private:
    // Default assignment operator to silence warning C4512.
    MyFunction001&amp; operator=(const MyFunction001&amp;);

    int&amp; m_evenCount; // the number of even variables in the vector.
};




int main(int argc, char **argv)
{

    int NumThreads = SpUtils::DefaultNumThreads();

    const int NbLoops = 3;
    const int NbInnerLoops = 2;
    static_assert(NbInnerLoops &lt;= NbLoops, "Nb inner loops cannot be greater than Nb Loops");

    const int NbDomains = 5;
    const int NbParticlesPerDomain = 10;
    const double BoxWidth = 1;
    const double displacement = 0.00001;

    const int NbReplicas = 5;
    std::array&lt;double,NbReplicas&gt; betas;
    std::array&lt;double,NbReplicas&gt; temperatures;

    const double MinTemperature = 0.5;
    const double MaxTemperature = 1.5;

    for(int idxReplica = 0 ; idxReplica &lt; NbReplicas ; ++idxReplica){
        betas[idxReplica] = 1;
        temperatures[idxReplica] = MinTemperature + double(idxReplica)*(MaxTemperature-MinTemperature)/double(NbReplicas-1);
    }

    std::array&lt;size_t,NbReplicas&gt; cptGeneratedSeq = {0};

    ///////////////////////////////////////////////////////////////////////////
    /// With a possible failure move
    ///////////////////////////////////////////////////////////////////////////

    const bool runSeqMove = false;
    const bool runTaskMove = false;
    const bool runSpecMove = false;

    std::array&lt;double,NbReplicas&gt; energySeq = {0};

    const int MaxIterationToMove = 5;
    const double collisionLimit = 0.00001;


    std::array&lt;unsigned int,3&gt; SleepTimes{0, 500,1000};

    for (const int&amp; value : SleepTimes) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";



    //Small Horse Race

    string ch0 = "Small Horse Race";
    string chNb = to_string(4);
    ch0=ch0+chNb;

    NumThreads = SpUtils::DefaultNumThreads();
    std::cout&lt;&lt;"Nb Thread="&lt;&lt;NumThreads&lt;&lt;"\n";
    NumThreads = 2;
    std::cout&lt;&lt;"Nb Thread="&lt;&lt;NumThreads&lt;&lt;"\n";

    SpTimer T0;

    for(auto SleepTime : SleepTimes){
        
        SpRuntime My_Runtime(NumThreads); 

        My_Runtime.setSpeculationTest(
            [](const int, const SpProbability&amp;) -&gt; bool
            {
                return true;
            });

        const int arraySize = 6;
        //int val[arraySize] = {0};
        int val[arraySize];

        for (int i=0; i&lt;arraySize; ++i)
        {
            val[i]=0;
        }

        cout&lt;&lt;"Array : ";
        for (const int&amp; value : val) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";


        UTestRaceChecker counterAccess;
        string ChInfo,ChInfoPlus;
        ChInfo = "Runtime Array Process";

        My_Runtime.task(SpReadArray(val,SpArrayView(arraySize)), 
        [](SpArrayAccessor&lt;const int&gt;&amp; /*valParam*/){}).setTaskName("Small Horse Race");
 
            for(int idx = 0 ; idx &lt; arraySize ; ++idx){
                ChInfoPlus = ChInfo+to_string(idx);

                My_Runtime.task(SpWrite(val[idx]),
                                      SpReadArray(val,SpArrayView(arraySize).removeItem(idx)),
                                      [SleepTime,idx,&amp;counterAccess]
                                      (int&amp; valParam, const SpArrayAccessor&lt;const int&gt;&amp; valArray) -&gt; bool {
                    {
                        counterAccess.lock();
                        counterAccess.addWrite(&amp;valParam);
                        for(int idxTest = 0 ; idxTest &lt; valArray.getSize() ; ++idxTest){
                            counterAccess.addRead(&amp;valArray.getAt(idxTest));
                        }
                        counterAccess.unlock();
                    }

                    string ChNumidx=to_string(idx);

                    cout&lt;&lt;"TimeSleep="&lt;&lt;SleepTime&lt;&lt;" Idx="&lt;&lt;idx;
                    cout&lt;&lt;" valParam1="&lt;&lt;valParam;

                    if (1==1) {
                         if(idx == 1){
                            valParam += 2;
                        }
                        if(idx == 3){
                            valParam += 1;
                        }
                        if(idx == 5){
                            valParam += 10;
                        }
                    }
                    cout&lt;&lt;" valParam2="&lt;&lt;valParam&lt;&lt;"\n";

                    usleep(SleepTime);

                    {
                        counterAccess.lock();
                        counterAccess.releaseWrite(&amp;valParam);
                        for(int idxTest = 0 ; idxTest &lt; valArray.getSize() ; ++idxTest){
                            counterAccess.releaseRead(&amp;valArray.getAt(idxTest));
                        }
                        counterAccess.unlock();
                    }

                    return (idx == 3 || idx == 5);
                }).setTaskName(ChInfoPlus); //END runtime;
            }
            My_Runtime.waitAllTasks();
            My_Runtime.stopAllThreads();

            My_Runtime.generateDot("TestRaceThread.dot",true);

            My_Runtime.generateTrace("TestRaceThread.svg");

        cout&lt;&lt;"Array : ";
        for (const int&amp; value : val) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";
        

    }//END FOR


    T0.stop();
    cout&lt;&lt;"Delta Time="&lt;&lt;T0.getElapsed()&lt;&lt;"\n";

    SpPhiloxGenerator&lt;double&gt; randGen(0);


}



 
#pragma GCC diagnostic pop</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Code Test Vector Buffer</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"



#include "Data/SpDataAccessMode.hpp"
#include "Utils/SpUtils.hpp"
#include "Random/SpPhiloxGenerator.hpp"


#include "mcglobal.hpp"



#include "Data/SpDataAccessMode.hpp"
#include "Utils/SpUtils.hpp"

#include "Task/SpTask.hpp"
#include "Legacy/SpRuntime.hpp"
#include "Utils/SpTimer.hpp"
#include "Utils/small_vector.hpp"
#include "Utils/SpBufferDataView.hpp"
#include "Utils/SpArrayView.hpp"
#include "Utils/SpHeapBuffer.hpp"


#include "UTester.hpp"
#include "utestUtils.hpp"



#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;



using namespace std;

template &lt;typename C&gt; void print(const string&amp; s, const C&amp; c) {
    cout &lt;&lt; s;
    for (const auto&amp; e : c) { cout &lt;&lt; e &lt;&lt; " "; }
    cout &lt;&lt; endl;
}

void fillVector(vector&lt;int&gt;&amp; v)
{
    // A local static variable.
    static int nextValue = 1;

    // The lambda expression that appears in the following call to
    // the generate function modifies and uses the local static
    // variable nextValue.
    generate(v.begin(), v.end(), [] { return nextValue++; });
    //WARNING: this isn't thread-safe and is shown for illustration only
}


int gen()
{
    static int i = 0;
    return ++i;
}

class MyFunction001
{
public:
    // The required constructor for this example.
    explicit MyFunction001(int&amp; evenCount)
        : m_evenCount(evenCount) { }

    // The function-call operator prints whether the number is
    // even or odd. If the number is even, this method updates
    // the counter.
    void operator()(int n) const {
        cout &lt;&lt; n;

        if (n % 2 == 0) {
            cout &lt;&lt; " is even " &lt;&lt; endl;
            ++m_evenCount;
        } else {
            cout &lt;&lt; " is odd " &lt;&lt; endl;
        }
    }

private:
    // Default assignment operator to silence warning C4512.
    MyFunction001&amp; operator=(const MyFunction001&amp;);

    int&amp; m_evenCount; // the number of even variables in the vector.
};




int main(int argc, char **argv)
{

    int NumThreads = SpUtils::DefaultNumThreads();

    const int NbLoops = 3;
    const int NbInnerLoops = 2;
    static_assert(NbInnerLoops &lt;= NbLoops, "Nb inner loops cannot be greater than Nb Loops");

    const int NbDomains = 5;
    const int NbParticlesPerDomain = 10;
    const double BoxWidth = 1;
    const double displacement = 0.00001;

    const int NbReplicas = 5;
    std::array&lt;double,NbReplicas&gt; betas;
    std::array&lt;double,NbReplicas&gt; temperatures;

    const double MinTemperature = 0.5;
    const double MaxTemperature = 1.5;

    for(int idxReplica = 0 ; idxReplica &lt; NbReplicas ; ++idxReplica){
        betas[idxReplica] = 1;
        temperatures[idxReplica] = MinTemperature + double(idxReplica)*(MaxTemperature-MinTemperature)/double(NbReplicas-1);
    }

    std::array&lt;size_t,NbReplicas&gt; cptGeneratedSeq = {0};

    ///////////////////////////////////////////////////////////////////////////
    /// With a possible failure move
    ///////////////////////////////////////////////////////////////////////////

    const bool runSeqMove = false;
    const bool runTaskMove = false;
    const bool runSpecMove = false;

    std::array&lt;double,NbReplicas&gt; energySeq = {0};

    const int MaxIterationToMove = 5;
    const double collisionLimit = 0.00001;


    if (1==1)
    {
        const int initVal = 1;
        int writeVal = 0;

        NumThreads=6;
        SpRuntime My_Runtime2(NumThreads); 

        small_vector&lt;int&gt; vs;
        std::cout &lt;&lt; "std::allocator&lt;int&gt;:"                         &lt;&lt; '\n'
            &lt;&lt; "  sizeof (vs):     " &lt;&lt; sizeof (vs)           &lt;&lt; '\n'
            &lt;&lt; "  Maximum size:    " &lt;&lt; vs.max_size ()        &lt;&lt; "\n\n";

        SpHeapBuffer&lt;small_vector&lt;int&gt;&gt; heapBuffer;

        int valueN=0;
        int valueM=0;

        for(int idx = 0 ; idx &lt; 6 ; ++idx){
            auto vectorBuffer = heapBuffer.getNewBuffer();

            
            //On écrit dans 6 buffers
            My_Runtime2.task(SpWrite(vectorBuffer.getDataDep()),
            [&amp;](SpDataBuffer&lt;small_vector&lt;int&gt;&gt; ) mutable
            {
                valueN=idx;  
                usleep(1000);
            }
            ).setTaskName("Write Vector Buffer");
            
            valueM=valueN;
            //Puis on lit 2 fois
            for(int idxSub = 0 ; idxSub &lt; 2 ; ++idxSub){
                My_Runtime2.task(SpRead(vectorBuffer.getDataDep()),
                    [=](const SpDataBuffer&lt;small_vector&lt;int&gt;&gt;)
                    {
                        
                        cout&lt;&lt;"idx="&lt;&lt;idx&lt;&lt;" idSub="&lt;&lt;idxSub&lt;&lt;" valueN="&lt;&lt;valueN&lt;&lt;" valueM="&lt;&lt;valueM&lt;&lt;"\n";
                        usleep(2000);
                       
                    }
                    ).setTaskName("Read Vector Buffer");;
            }    
        }
        My_Runtime2.waitAllTasks();
        My_Runtime2.stopAllThreads();
        My_Runtime2.generateDot("RuntimeVectorBuffer.dot",true);
        My_Runtime2.generateTrace("RuntimeVectorBuffer.svg");
    }




}



 
#pragma GCC diagnostic pop</code></pre>
</div>
</div>
</div>
</div>
<div class="listingblock">
<div class="title">Code Draft Tests</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"






#include "Data/SpDataAccessMode.hpp"
#include "Utils/SpUtils.hpp"
#include "Random/SpPhiloxGenerator.hpp"


#include "mcglobal.hpp"


#include "Task/SpTask.hpp"
#include "Legacy/SpRuntime.hpp"
#include "Utils/SpTimer.hpp"
#include "Utils/small_vector.hpp"
#include "Utils/SpBufferDataView.hpp"
#include "Utils/SpArrayView.hpp"
#include "Utils/SpHeapBuffer.hpp"


#include "UTester.hpp"
#include "utestUtils.hpp"



#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;



using namespace std;

template &lt;typename C&gt; void print(const string&amp; s, const C&amp; c) {
    cout &lt;&lt; s;
    for (const auto&amp; e : c) { cout &lt;&lt; e &lt;&lt; " "; }
    cout &lt;&lt; endl;
}

void fillVector(vector&lt;int&gt;&amp; v)
{
    // A local static variable.
    static int nextValue = 1;

    // The lambda expression that appears in the following call to
    // the generate function modifies and uses the local static
    // variable nextValue.
    generate(v.begin(), v.end(), [] { return nextValue++; });
    //WARNING: this isn't thread-safe and is shown for illustration only
}


int gen()
{
    static int i = 0;
    return ++i;
}

class MyFunction001
{
public:
    // The required constructor for this example.
    explicit MyFunction001(int&amp; evenCount)
        : m_evenCount(evenCount) { }

    // The function-call operator prints whether the number is
    // even or odd. If the number is even, this method updates
    // the counter.
    void operator()(int n) const {
        cout &lt;&lt; n;

        if (n % 2 == 0) {
            cout &lt;&lt; " is even " &lt;&lt; endl;
            ++m_evenCount;
        } else {
            cout &lt;&lt; " is odd " &lt;&lt; endl;
        }
    }

private:
    // Default assignment operator to silence warning C4512.
    MyFunction001&amp; operator=(const MyFunction001&amp;);

    int&amp; m_evenCount; // the number of even variables in the vector.
};




int main(int argc, char **argv)
{

    int NumThreads = SpUtils::DefaultNumThreads();

    const int NbLoops = 3;
    const int NbInnerLoops = 2;
    static_assert(NbInnerLoops &lt;= NbLoops, "Nb inner loops cannot be greater than Nb Loops");

    const int NbDomains = 5;
    const int NbParticlesPerDomain = 10;
    const double BoxWidth = 1;
    const double displacement = 0.00001;

    const int NbReplicas = 5;
    std::array&lt;double,NbReplicas&gt; betas;
    std::array&lt;double,NbReplicas&gt; temperatures;

    const double MinTemperature = 0.5;
    const double MaxTemperature = 1.5;

    for(int idxReplica = 0 ; idxReplica &lt; NbReplicas ; ++idxReplica){
        betas[idxReplica] = 1;
        temperatures[idxReplica] = MinTemperature + double(idxReplica)*(MaxTemperature-MinTemperature)/double(NbReplicas-1);
    }

    std::array&lt;size_t,NbReplicas&gt; cptGeneratedSeq = {0};

    ///////////////////////////////////////////////////////////////////////////
    /// With a possible failure move
    ///////////////////////////////////////////////////////////////////////////

    const bool runSeqMove = false;
    const bool runTaskMove = false;
    const bool runSpecMove = false;

    std::array&lt;double,NbReplicas&gt; energySeq = {0};

    const int MaxIterationToMove = 5;
    const double collisionLimit = 0.00001;



    SpRuntime runtime(NumThreads); 
    std::cout&lt;&lt;"Nb Thread="&lt;&lt;NumThreads&lt;&lt;"\n";
    SpTimer timer;


    int v=1; 
    int r=0;

    std::cout&lt;&lt;"v="&lt;&lt;v&lt;&lt;" r="&lt;&lt;r&lt;&lt;"\n";

    runtime.task(SpRead(v),SpWrite(r),
    [] (const int &amp;,int r1) {
        r1=10;
    } ).setTaskName("First Runtime");

    runtime.task(SpRead(v),
    [] (const int &amp;) {
        
    } ).setTaskName("Second Runtime");

    std::cout&lt;&lt;"v="&lt;&lt;v&lt;&lt;" r="&lt;&lt;r&lt;&lt;"\n";

    //=============================================
    int p;
    auto Area=[=] (int a,int b)-&gt;int
    {
        return p*a*b;
    };
    p=10;
    std::cout&lt;&lt;"Result1="&lt;&lt;Area(2,3)&lt;&lt;"\n";

    //=============================================
    int p2=100;
    auto Area2=[&amp;] (int a,int b)
     {
        p2=50;
        return p2*a*b;
    };
    std::cout&lt;&lt;"Result2="&lt;&lt;Area2(2,3)&lt;&lt;"\n";

    //=============================================

    
    auto Area3=[] (int a,int b)
     {
        return a*b;
    };

    std::cout&lt;&lt;"Result3="&lt;&lt;Area3(2,3)&lt;&lt;"\n";

    //=============================================
    int v1;
    int g=3;
    auto Area4=[&amp;,g] (int a,int b)
     {
        return v1+a*b;
    };
    v1=1;
    std::cout&lt;&lt;"Result3="&lt;&lt;Area3(2,3)&lt;&lt;"\n";


    int x = 1;
    auto valueLambda = [=]() { std::cout &lt;&lt; x &lt;&lt; std::endl; };
    auto refLambda = [&amp;]() { std::cout &lt;&lt; x &lt;&lt; std::endl; };
    x = 13;
    valueLambda();
    refLambda();


    //=============================================
    int m = 0;
    int n = 0;
    [&amp;, n] (int a) mutable { m = ++n + a; }(4);
    std::cout &lt;&lt;"m="&lt;&lt;m &lt;&lt; std::endl &lt;&lt;"n="&lt;&lt; n &lt;&lt; std::endl;

    m = 0;
    n = 0;
    auto Fonc1=[&amp;,n] (int a) mutable { m = n++ + a; n=20; };
    Fonc1(6);
    std::cout &lt;&lt;"m="&lt;&lt;m &lt;&lt; std::endl &lt;&lt;"n="&lt;&lt; n &lt;&lt; std::endl;


    //m = 0;
    //n = 0;
    //auto Fonc2=[&amp;,n] (int a) { m = n++ + a; n=20; }; // Error no mutable
    //Fonc2(6);
    //std::cout &lt;&lt;"m="&lt;&lt;m &lt;&lt; std::endl &lt;&lt;"n="&lt;&lt; n &lt;&lt; std::endl;



    const int elementCount = 9;

    // Create a vector object with each element set to 1.
    vector&lt;int&gt; vvv0 {1,2,3,4,5,6,7,8,9,10,11};
    cout &lt;&lt; "v0: "&lt;&lt; vvv0.data() &lt;&lt; endl;
    for (const int&amp; value : vvv0) { cout &lt;&lt; value &lt;&lt; "  "; }
    cout &lt;&lt; "\n";

    cout &lt;&lt;vvv0[4]&lt;&lt;"\n";
    cout &lt;&lt;vvv0.at(4)&lt;&lt;"\n"; //Better to used give exception if up range 

    cout &lt;&lt; "\n";

    vector&lt;int&gt; vvv1(10);
    for (const int&amp; value : vvv1) { cout &lt;&lt; value &lt;&lt; "  "; }
    cout &lt;&lt; "\n";
  
    // using std::generate
    std::generate(vvv1.begin(), vvv1.end(), gen);
    for (const int&amp; value : vvv1) { cout &lt;&lt; value &lt;&lt; "  "; }
    cout &lt;&lt; "\n";
    vector&lt;int&gt;::iterator i1;
    for (i1 = vvv1.begin(); i1 != vvv1.end(); ++i1) {
        cout &lt;&lt; *i1 &lt;&lt; " ";
    }
    cout &lt;&lt; "\n";




    cout &lt;&lt; "\n";
    vector&lt;int&gt; vvv(elementCount, 1);


    cout &lt;&lt; "v: "&lt;&lt; vvv.data() &lt;&lt; endl;
    for (const int&amp; value : vvv) { cout &lt;&lt; value &lt;&lt; "  "; }
    cout &lt;&lt; "\n";


    // These variables hold the previous two elements of the vector.
    int xx = 1;
    int yy = 1;

    // Sets each element in the vector to the sum of the
    // previous two elements.
    generate_n(vvv.begin() + 2,
        elementCount - 2,
        [=]() mutable throw() -&gt; int { // lambda is the 3rd parameter
        // Generate current value.
        int n = xx + yy;
        // Update previous two values.
        xx = yy;
        yy = n;
        return n;
    });
    print("vector v after call to generate_n() with lambda: ", vvv);

    // Print the local variables x and y.
    // The values of x and y hold their initial values because
    // they are captured by value.
    cout &lt;&lt; "x: " &lt;&lt; xx &lt;&lt; " y: " &lt;&lt; yy &lt;&lt; endl;

    // Fill the vector with a sequence of numbers
    fillVector(vvv);
    print("vector v after 1st call to fillVector(): ", vvv);
    // Fill the vector with the next sequence of numbers
    fillVector(vvv);
    print("vector v after 2nd call to fillVector(): ", vvv);


    cout &lt;&lt; endl;


    //Assign the lambda expression that adds two numbers to an auto variable.
    auto f1 = [](int x, int y) { return x + y; };

    cout &lt;&lt; f1(2, 3) &lt;&lt; endl;

    // Assign the same lambda expression to a function object.
    function&lt;int(int, int)&gt; f2 = [](int x, int y) { return x + y; };

    cout &lt;&lt; f2(3, 4) &lt;&lt; endl;

    cout &lt;&lt; endl;

    /*int yw = 32;
    auto answer = [yw]() constexpr
    {
        int xw = 10;
        return yw + xw;
    };

    constexpr int Increment(int n)
    {
        return [n] { return n + 1; }();
    }
    */



   // Create a vector object that contains 9 elements.
    vector&lt;int&gt; vn;
    for (int i = 1; i &lt; 10; ++i) {
        vn.push_back(i);
    }

    // Count the number of even numbers in the vector by
    // using the for_each function and a function object.
    int evenCount = 0;
    for_each(vn.begin(), vn.end(), MyFunction001(evenCount));

    // Print the count of even numbers to the console.
    cout &lt;&lt; "There are " &lt;&lt; evenCount
        &lt;&lt; " even numbers in the vector." &lt;&lt; endl;

    cout &lt;&lt; endl;

    const int NbTab=10;
    double Tab[NbTab]={0};
    for (int i=0; i&lt;NbTab; ++i)
    {
        Tab[i]=0.01*double(i);
    }
    UTestRaceChecker counterAccess;


    runtime.task(SpReadArray(Tab,SpArrayView(NbTab)), 
        [](SpArrayAccessor&lt;const double&gt;&amp; ){}
    ).setTaskName("Runtime read Array");


    for (const double&amp; value : Tab) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";



    for(int idx = 0 ; idx &lt; NbTab ; ++idx){
                runtime.task(SpWrite(Tab[idx]),
                             SpReadArray(Tab,SpArrayView(NbTab).removeItem(idx)),
                                     
                [idx](double&amp; valParam, const SpArrayAccessor&lt;const double&gt;&amp; valArray) -&gt; bool
                {
                    {
                       
                            if(idx == 3){
                                valParam += 1;
                            }
                            if(idx == 5){
                                valParam += 10;
                            }
                            usleep(1000);

                            cout&lt;&lt;"valParam="&lt;&lt;valParam&lt;&lt;"\n";


                        return (idx == 3 || idx == 5); 
                    } 
                }
                ).setTaskName("Runtime Array Process"); //END runtime
            } //END FOR


    for (const double&amp; value : Tab) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";

    //specx part




    runtime.waitAllTasks();

    runtime.stopAllThreads();

    timer.stop();

    runtime.generateDot("Test.dot",true);

    runtime.generateTrace("Test.svg");
  

    //std::array&lt;unsigned int,2&gt; SleepTimes{0, 500};

    std::array&lt;unsigned int,3&gt; SleepTimes{0, 500,1000};

    for (const int&amp; value : SleepTimes) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";



    //Small Horse Race

    string ch0 = "Small Horse Race";
    string chNb = to_string(4);
    ch0=ch0+chNb;

    NumThreads = SpUtils::DefaultNumThreads();
    std::cout&lt;&lt;"Nb Thread="&lt;&lt;NumThreads&lt;&lt;"\n";
    NumThreads = 2;
    std::cout&lt;&lt;"Nb Thread="&lt;&lt;NumThreads&lt;&lt;"\n";

    SpTimer T0;

    for(auto SleepTime : SleepTimes){
        
        SpRuntime My_Runtime(NumThreads); 

        My_Runtime.setSpeculationTest(
            [](const int, const SpProbability&amp;) -&gt; bool
            {
                return true;
            });

        const int arraySize = 6;
        //int val[arraySize] = {0};
        int val[arraySize];

        for (int i=0; i&lt;arraySize; ++i)
        {
            val[i]=0;
        }

        cout&lt;&lt;"Array : ";
        for (const int&amp; value : val) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";


        UTestRaceChecker counterAccess;
        string ChInfo,ChInfoPlus;
        ChInfo = "Runtime Array Process";

        My_Runtime.task(SpReadArray(val,SpArrayView(arraySize)), 
        [](SpArrayAccessor&lt;const int&gt;&amp; /*valParam*/){}).setTaskName("Small Horse Race");
 
            for(int idx = 0 ; idx &lt; arraySize ; ++idx){
                ChInfoPlus = ChInfo+to_string(idx);

                My_Runtime.task(SpWrite(val[idx]),
                                      SpReadArray(val,SpArrayView(arraySize).removeItem(idx)),
                                      [SleepTime,idx,&amp;counterAccess]
                                      (int&amp; valParam, const SpArrayAccessor&lt;const int&gt;&amp; valArray) -&gt; bool {
                    {
                        counterAccess.lock();
                        counterAccess.addWrite(&amp;valParam);
                        for(int idxTest = 0 ; idxTest &lt; valArray.getSize() ; ++idxTest){
                            counterAccess.addRead(&amp;valArray.getAt(idxTest));
                        }
                        counterAccess.unlock();
                    }

                    string ChNumidx=to_string(idx);

                    cout&lt;&lt;"TimeSleep="&lt;&lt;SleepTime&lt;&lt;" Idx="&lt;&lt;idx;
                    cout&lt;&lt;" valParam1="&lt;&lt;valParam;

                    if (1==1) {
                         if(idx == 1){
                            valParam += 2;
                        }
                        if(idx == 3){
                            valParam += 1;
                        }
                        if(idx == 5){
                            valParam += 10;
                        }
                    }
                    cout&lt;&lt;" valParam2="&lt;&lt;valParam&lt;&lt;"\n";

                    usleep(SleepTime);

                    {
                        counterAccess.lock();
                        counterAccess.releaseWrite(&amp;valParam);
                        for(int idxTest = 0 ; idxTest &lt; valArray.getSize() ; ++idxTest){
                            counterAccess.releaseRead(&amp;valArray.getAt(idxTest));
                        }
                        counterAccess.unlock();
                    }

                    return (idx == 3 || idx == 5);
                }).setTaskName(ChInfoPlus); //END runtime;
            }
            My_Runtime.waitAllTasks();
            My_Runtime.stopAllThreads();

            My_Runtime.generateDot("TestRaceThread.dot",true);

            My_Runtime.generateTrace("TestRaceThread.svg");

        cout&lt;&lt;"Array : ";
        for (const int&amp; value : val) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";
        

    }//END FOR


    T0.stop();
    cout&lt;&lt;"Delta Time="&lt;&lt;T0.getElapsed()&lt;&lt;"\n";

    SpPhiloxGenerator&lt;double&gt; randGen(0);

    //cout&lt;&lt;"Value SpPhiloGenerator="&lt;&lt;randGen&lt;&lt;"\n";


    //**********************************************************

    if (1==1)
    {
        const int initVal = 1;
        int writeVal = 0;

        NumThreads=6;
        SpRuntime My_Runtime2(NumThreads); 

        small_vector&lt;int&gt; vs;
        std::cout &lt;&lt; "std::allocator&lt;int&gt;:"                         &lt;&lt; '\n'
            &lt;&lt; "  sizeof (vs):     " &lt;&lt; sizeof (vs)           &lt;&lt; '\n'
            &lt;&lt; "  Maximum size:    " &lt;&lt; vs.max_size ()        &lt;&lt; "\n\n";

        SpHeapBuffer&lt;small_vector&lt;int&gt;&gt; heapBuffer;

        int valueN=0;
        int valueM=0;

        for(int idx = 0 ; idx &lt; 6 ; ++idx){
            auto vectorBuffer = heapBuffer.getNewBuffer();

            
            //On écrit dans 6 buffers
            My_Runtime2.task(SpWrite(vectorBuffer.getDataDep()),
            [&amp;](SpDataBuffer&lt;small_vector&lt;int&gt;&gt; ) mutable
            {
                valueN=idx;  
                usleep(1000);
            }
            ).setTaskName("Write Vector Buffer");
            
            valueM=valueN;
            //Puis on lit 2 fois
            for(int idxSub = 0 ; idxSub &lt; 2 ; ++idxSub){
                My_Runtime2.task(SpRead(vectorBuffer.getDataDep()),
                    [=](const SpDataBuffer&lt;small_vector&lt;int&gt;&gt;)
                    {
                        
                        cout&lt;&lt;"idx="&lt;&lt;idx&lt;&lt;" idSub="&lt;&lt;idxSub&lt;&lt;" valueN="&lt;&lt;valueN&lt;&lt;" valueM="&lt;&lt;valueM&lt;&lt;"\n";
                        usleep(2000);
                       
                    }
                    ).setTaskName("Read Vector Buffer");;
            }    
        }
        My_Runtime2.waitAllTasks();
        My_Runtime2.stopAllThreads();
        My_Runtime2.generateDot("Runtime2.dot",true);
        My_Runtime2.generateTrace("Runtime2.svg");
    }


  //**********************************************************

    if (1==1)
    {

        cout&lt;&lt;"===================================\n";

        NumThreads=2;
        SpRuntime My_Runtime3(NumThreads); 

        //SpRuntime&lt;SpSpeculativeModel::SP_MODEL_2&gt; My_Runtime3;
        //cout&lt;&lt;":"&lt;&lt;My_Runtime3.getValue()&lt;&lt;"\n";

        My_Runtime3.setSpeculationTest(
            [](const int /*inNbReadyTasks*/,
            const SpProbability&amp; /*inProbability*/) -&gt; bool
            {
                // Always speculate
                //usleep(50000);
                return true;
            } 
        );

        int val = 0;
        std::promise&lt;int&gt; promise3;
        //la promesse que doit remplir le thread annexe

         My_Runtime3.task(SpRead(val)
            , 
            [&amp;promise3](const int&amp; /*valParam*/)
            {
                usleep(100);
                promise3.get_future().get();
                //Retourne un objet future qui a le même état asynchrone associé que cet objet promise.
            }
        ).setTaskName("First task");

       
        
        for(int idx = 0; idx &lt; 1; idx++) {
          My_Runtime3.task(SpWrite(val), 
              [](int&amp; valParam)  
              {
                cout&lt;&lt;"CTRL Val in certain task="&lt;&lt;valParam&lt;&lt;"\n";
                usleep(500);
              }
          ).setTaskName("Certain task -- " + std::to_string(idx));
        }

        
        
        const int nbUncertainTasks = 6;

        for(int idx = 0 ; idx &lt; nbUncertainTasks ; ++idx){
            My_Runtime3.task(SpPotentialWrite(val), 
               [](int&amp; valParam) -&gt; bool
                {
                   cout&lt;&lt;"CTRL Val in uncertain task="&lt;&lt;valParam&lt;&lt;"\n";
                   usleep(1000);
                   return true;
                }
            ).setTaskName("Uncertain task -- " + std::to_string(idx));
        }
        

        /*
        for(int idx = 2; idx &lt; 4; idx++) {
          My_Runtime3.task(SpWrite(val), 
              [](int&amp; valParam)  
              {
                usleep(1500);
              }
           ).setTaskName("Certain task -- " + std::to_string(idx));
        }
        */
        
        My_Runtime3.task(SpWrite(val), 
              []([[maybe_unused]] int&amp; valParam)
              {
                usleep(2000);
              }
        ).setTaskName("Last-task");

        promise3.set_value(0);
        //L'opération se comporte comme si set_value , set_exception , 
        //set_value_at_thread_exit et set_exception_at_thread_exit acquéraient 
        //un seul mutex associé à l'objet de promesse lors de la mise à jour de 
        //l'objet de promesse.
    
        //Une exception est levée s'il n'y a pas d'état partagé ou si 
        //l'état partagé stocke déjà une valeur ou une exception.
        //Les appels à cette fonction n'introduisent pas de courses de 
        //données avec les appels à get_future (ils n'ont donc pas besoin 
        //de se synchroniser les uns avec les autres).



        My_Runtime3.waitAllTasks();

        My_Runtime3.generateDot("Runtime3.dot",true);
        My_Runtime3.generateTrace("Runtime3.svg");


    }



    if (1==1)
    {

        SpDebug::Controller.isEnable();

        cout&lt;&lt;"===================================\n";
            const int NbThreads = 2;
            SpRuntime My_Runtime4(NbThreads);

            int readVal = 0;
            std::promise&lt;int&gt; promise0;
            std::promise&lt;int&gt; promise1;
            std::promise&lt;int&gt; promise2;

            My_Runtime4.task(SpRead(readVal),
                [&amp;](const int&amp; /*readVal*/)
                {
                   promise0.get_future().get();
                   usleep(2000);
                }).setTaskName("Promise0");

            My_Runtime4.task(SpRead(readVal),
                [&amp;](const int&amp; /*readVal*/)
                {
                    promise1.get_future().get();
                    usleep(2000);
                }).setTaskName("Promise1");

            My_Runtime4.task(SpRead(readVal),
                [&amp;](const int&amp; /*readVal*/)
                {
                    promise2.get_future().get();
                    usleep(2000);
                }).setTaskName("Promise2");

            My_Runtime4.waitRemain(3);

            promise0.set_value(0);

            //My_Runtime4

            My_Runtime4.waitRemain(2);

            promise1.set_value(0);

            My_Runtime4.waitRemain(1);

            promise2.set_value(0);

            My_Runtime4.waitAllTasks();

            My_Runtime4.generateDot("Runtime4.dot",true);
            My_Runtime4.generateTrace("Runtime4.svg");
        }

    if (1==1)
    {



    


        {

        
        const int NbTasks = 10;
        const int NbThreads = 10;

        std::promise&lt;int&gt; promises[NbTasks];
        //Fix Taches Pronises
        SpRuntime My_Runtime5(NbThreads);

        std::cout&lt;&lt;"Nb Thread="&lt;&lt;My_Runtime5.getNbThreads()&lt;&lt;"\n";
        std::cout&lt;&lt;"Nb CPU Workers="&lt;&lt;My_Runtime5.getNbCpuWorkers()&lt;&lt;"\n";

            int readVal = 0;

            for(int idxTask = 0 ; idxTask &lt; NbTasks ; ++idxTask){
                My_Runtime5.task(SpRead(readVal),
                    [&amp;,idxTask](const int&amp; /*readVal*/)
                    {
                        promises[idxTask].get_future().get();
                        usleep(1000);
                        //usleep(100*NbTasks);
                    });
            }

            for(int idxTask = NbTasks ; idxTask &lt; 2*NbTasks ; ++idxTask){
                My_Runtime5.waitRemain(idxTask); //mutexFinishedTasks
                
            }


            //for(int idxTask = 0 ; idxTask &lt; NbTasks ; ++idxTask){
            //    My_Runtime5.waitRemain(idxTask); //mutexFinishedTasks
            //}

            
            for(int idxTaskPromise = 0 ; idxTaskPromise &lt; NbTasks ; ++idxTaskPromise)
            {
                promises[idxTaskPromise].set_value(0);
                //Une exception est levée s'il n'y a pas d'état partagé ou si 
                //l'état partagé stocke déjà une valeur ou une exception.

                //usleep(2000);
                for(int idxTask = NbTasks-idxTaskPromise-1 ; idxTask &lt; 2*NbTasks ; ++idxTask)
                {
                    My_Runtime5.waitRemain(idxTask);
                }
            }
            

            My_Runtime5.waitAllTasks();

            My_Runtime5.generateDot("Runtime5.dot",true);
            My_Runtime5.generateTrace("Runtime5.svg");
        }


            const int NbThreads = 10;
            SpRuntime My_Runtime6(NbThreads);

            int readVal = 0;
            std::promise&lt;int&gt; promise0;
            std::promise&lt;int&gt; promise1;


            My_Runtime6.task(SpRead(readVal),
                [&amp;](const int&amp; /*readVal*/)
                {
                   promise0.get_future().get();
                   usleep(2000);
                }).setTaskName("Promise0");

            My_Runtime6.task(SpRead(readVal),
                [&amp;](const int&amp; /*readVal*/)
                {
                    promise1.get_future().get();
                    usleep(2000);
                }).setTaskName("Promise1");

 
            My_Runtime6.waitRemain(3);

            promise0.set_value(0);
            My_Runtime6.waitRemain(2);

            promise1.set_value(0);



            My_Runtime6.waitAllTasks();

            My_Runtime6.generateDot("Runtime6.dot",true);
            My_Runtime6.generateTrace("Runtime6.svg");

    }


    if (1==0)
    {

        cout&lt;&lt;"===================================\n";



            const int NbThreads = 2;
            SpRuntime My_Runtime5(NbThreads);

            int readVal = 0;
            

            My_Runtime5.task(SpRead(readVal),
                [&amp;](const int&amp; /*readVal*/)
                {
                   
                   usleep(2000);
                }).setTaskName("Promise0");

            My_Runtime5.task(SpRead(readVal),
                [&amp;](const int&amp; /*readVal*/)
                {
                    
                    usleep(2000);
                }).setTaskName("Promise1");


            My_Runtime5.waitRemain(2);

            My_Runtime5.waitAllTasks();

            My_Runtime5.generateDot("Runtime5.dot",true);
            My_Runtime5.generateTrace("Runtime5.svg");
        }


   if (1==1)
    {        
        const int NBB=500;
        const int NbTasks = NBB;
        const int NbThreads = NBB;

        
        double Tab[NbTasks]={0};
        for (int i=0; i&lt;NbTasks; ++i)
        {
            Tab[i]=0.01*double(i);
        }
        UTestRaceChecker counterAccess;

        std::promise&lt;int&gt; promises[NbTasks];
        //Fix Taches Pronises
        SpRuntime My_Runtime7(NbThreads);

        std::cout&lt;&lt;"Nb Thread="&lt;&lt;My_Runtime7.getNbThreads()&lt;&lt;"\n";
        std::cout&lt;&lt;"Nb CPU Workers="&lt;&lt;My_Runtime7.getNbCpuWorkers()&lt;&lt;"\n";

            int readVal = 0;

            for(int idxTask = 0 ; idxTask &lt; NbTasks ; ++idxTask){
                My_Runtime7.task(
                    SpRead(readVal),
                    SpReadArray(Tab,SpArrayView(NbTab))
                    ,
                    [&amp;,idxTask](
                        const int&amp; /*readVal*/,
                        SpArrayAccessor&lt;const double&gt;&amp;)
                    {
                        promises[idxTask].get_future().get();
                        usleep(1000);
                        
                    }).setTaskName("Runtime Array Process"+to_string(idxTask));

                
                
                
            }

            for (const double&amp; value : Tab) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";


            //for(int idxTask = 0 ; idxTask &lt; NbTasks ; ++idxTask)

            //My_Runtime7.task(SpWrite(Tab[0]),
            //    [](double&amp; valParam)
            //    {
            //    }
            //    );


/*
            for(int idx = 0 ; idx &lt; NbTasks ; ++idx){
                My_Runtime7.task(SpWrite(Tab[idx]),
                             SpReadArray(Tab,SpArrayView(NbTasks).removeItem(idx)),
                                     
                [idx](double&amp; valParam, const SpArrayAccessor&lt;const double&gt;&amp; valArray) -&gt; bool
                {
                    {
                            if(idx == 3){
                                valParam += 1;
                            }
                            if(idx == 5){
                                valParam += 10;
                            }
                            usleep(1000);
                            cout&lt;&lt;"valParam="&lt;&lt;valParam&lt;&lt;"\n";
                        return (idx == 3 || idx == 5); 
                    } 
                }
                ).setTaskName("Runtime Array Process"); //END runtime
            } //END FOR
*/
            

            for(int idxTask = NbTasks ; idxTask &lt; 2*NbTasks ; ++idxTask){
                
                
                My_Runtime7.waitRemain(idxTask); //mutexFinishedTasks
                
            }


            //for(int idxTask = 0 ; idxTask &lt; NbTasks ; ++idxTask){
            //    My_Runtime5.waitRemain(idxTask); //mutexFinishedTasks
            //}

            
            for(int idxTaskPromise = 0 ; idxTaskPromise &lt; NbTasks ; ++idxTaskPromise)
            {
                promises[idxTaskPromise].set_value(0);

                

                //Une exception est levée s'il n'y a pas d'état partagé ou si 
                //l'état partagé stocke déjà une valeur ou une exception.

                //usleep(2000);
                for(int idxTask = NbTasks-idxTaskPromise-1 ; idxTask &lt; 2*NbTasks ; ++idxTask)
                {
                    My_Runtime7.waitRemain(idxTask);
                }
            }

            for (const double&amp; value : Tab) { cout &lt;&lt; value &lt;&lt; "  "; }; cout &lt;&lt; "\n";
            

            My_Runtime7.waitAllTasks();

            My_Runtime7.generateDot("Runtime7.dot",true);
            My_Runtime7.generateTrace("Runtime7.svg");
        }



if (1==1)
    {
         
    }


}



 
#pragma GCC diagnostic pop</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer" style="border-top: 2px solid #e9e9e9; background-color: #fafafa; padding-bottom: 2em; padding-top: 2em;">
    <div class="container" style="display: flex; flex-direction: column; align-items: center; gap: 0.5em;">
        <div>
            <a href="https://www.cemosis.fr">
                <img src="../_/img/cemosis-logo.svg" alt="Cemosis logo" height="50">
            </a>
        </div>
        <span style="font-size: 0.8rem; color: #9e9e9e">© 2025 <a href="https://www.cemosis.fr" style="text-decoration: underline;">Cemosis</a>, Université de Strasbourg</span>
    </div>
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>


<script async src="../_/js/vendor/fontawesome-icon-defs.js"></script>
<script async src="../_/js/vendor/fontawesome.js"></script>
<script async src="../_/js/vendor/highlight.js"></script>


<script type="text/javascript">
function toggleFullScreen() {
   var doc = window.document;
   var docEl = doc.documentElement;

   var requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
   var cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

   if(!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
       requestFullScreen.call(docEl);
   }
   else {
       cancelFullScreen.call(doc);
   }
}
</script>
  </body>
</html>
