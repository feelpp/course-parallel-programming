= OpenMP Coding Practice

* Compiling a program for OpenMP is almost just like compiling a regular C or C++ program. For example, to compile MyProg.c you would use a command like:
*** gcc -fopenmp -o MyProg MyProg.c
*** gcc -fopenmp -o MyProg MyProg.cpp
*** g++ -c MyProg. cpp -o MyProg.o -fopenmp
*** g++ MyProg.o -o MyProg -fopenmp -lpthread


.Start
[.examp]
****
This start example illustrates how to do a task reduction and consists in calculating the sum of all elements of an array.
ifeval::[{showproof} >= 2]
.Code Start
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_Start.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_Start.cpp[]
----
====
//endif::[]
****



.Firstprivate
[.examp]
****
Specifies that each thread should have its own instance of a variable, and that the variable should be initialized with the value of the variable, because it exists before the parallel construct.
.Code Firstprivate
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_Firstprivate.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_Firstprivate.cpp[]
----
====
//endif::[]
****



.Private
[.examp]
****
The private clause declares the variables in the list to be private to each thread in a team.
.Code Private
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_Private.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_Private.cpp[]
----
====
//endif::[]
****



.Lastprivate
[.examp]
****
Specifies that the enclosing context's version of the variable is set equal to the private version of whichever thread executes the final iteration (for-loop construct) or last section (#pragma sections).

.Code Lastprivate
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_Lastprivate.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_Lastprivate.cpp[]
----
====
//endif::[]
****



.Linear
[.examp]
****
The linear clause provides a superset of the functionality provided by the private clause. 

.Code Linear
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_Linear.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_Linear.cpp[]
----
====
//endif::[]
****



.Schedule
[.examp]
****
Scheduling is a method in OpenMP to distribute iterations to different threads in for loop.

.Code Schedule
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_Schedule.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_Schedule.cpp[]
----
====
//endif::[]
****


.None
[.examp]
****
The none clause requires that each variable that is referenced in the construct, and that does not have a predetermined data-sharing attribute, must have its data-sharing attribute explicitly determined by being listed in a data-sharing attribute clause. 

.Code None
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_None.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_None.cpp[]
----
====
//endif::[]
****



.Task
[.examp]
****
The task pragma can be used to explicitly define a task. Use the task pragma when you want to identify a block of code to be executed in parallel with the code outside the task region. The task pragma can be useful for parallelizing irregular algorithms such as pointer chasing or recursive algorithms. 

This application consists of a thread, in an OpenMP parallel region, that spawns tasks.

.Code Task
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_Task.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_Task.cpp[]
----
====
//endif::[]
****


.Code Reduction
[.examp]
****
This example consists in calculating the sum of all elements of an array.
.Code Task Reduction
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_Task_reduction.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_Task_reduction.cpp[]
----
====
//endif::[]
****


.Code Reduction
[.examp]
****
Use the taskwait pragma to specify a wait for child tasks to be completed that are generated by the current task. This application consists of a thread, in an OpenMP parallel region that spawns tasks. It first spawns two tasks, then wait for these to complete before spawning a third task. The execution flow can be visualised below:
.Code Task Wait
[%collapsible.proof]
====
[%dynamic,cpp,filename="OpenMP_Task_wait.cpp",compile="openmp"]
----
include::ROOT:example$src/OpenMP/OpenMP_Task_wait.cpp[]
----
====
//endif::[]
****



...

